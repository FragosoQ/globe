<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Globo de Conex√µes (Deck.gl) - Rede de Pa√≠ses Selecionados</title>
    <script src="https://unpkg.com/deck.gl@^9.0.0-beta.2/dist.min.js"></script>

    <style type="text/css">
        /* Estilos CSS Base (Otimizado para Mobile) */
        body {
            background: #000000;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            /* Otimiza√ß√£o de toque para evitar interfer√™ncia do navegador (Permite zoom de pin√ßa) */
            touch-action: none; 
            -ms-touch-action: none; 
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        /* --- Logo Superior Esquerdo --- */
        #logo-top-left {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 110;
            background: rgba(0, 0, 0, 0.4);
            padding: 10px;
            border-radius: 6px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        #logo-top-left img {
            height: 60px;
            width: auto;
            object-fit: contain;
        }

        /* --- Bot√µes de Zoom (Escondidos por padr√£o) --- */
        #zoom-controls {
            display: none; 
        }
        
 /* üõë CARD DE INFORMA√á√ÉO: Canto Inferior Esquerdo (Configura√ß√£o Desktop) */
#info-wrapper {
    position: absolute;
    /* Posi√ß√£o em Desktop: Canto Inferior Esquerdo */
    bottom: 20px; 
    left: 20px; 
    right: auto;
    top: auto;
    z-index: 100;
    /* Permitir que o conte√∫do defina a largura em desktop/tablet */
    width: auto; 
    max-width: 300px; /* Limite a largura para n√£o ficar muito grande em desktops */
    display: flex;
    flex-direction: column-reverse; 
    box-shadow: 0 0 15px rgba(15, 212, 247, 0.4); 
    border-radius: 20px 20px 20px 20px; 
}

/* --- Mobile / Ecr√£s Pequenos (max-width: 768px) --- */
@media (max-width: 768px) {
    #info-wrapper {
        /* Centrar na parte inferior */
        left: 50%;
        right: auto;
        bottom: 120px; 
        /* Largura total com margem de 20px de cada lado */
        width: calc(100% - 40px);
        max-width: unset; /* Remove o limite */
        transform: translateX(-50%); /* Centraliza horizontalmente */
    }
}
        
        #floating-info {
            cursor: pointer; 
            width: 100%; /* üõë Ocupa 100% dos 250px definidos no wrapper */
            height: ; /* üõë Reduzida a altura para ser uma barra */
            /*background-color: rgba(7, 7, 10, 0.8);*/
            color: #FFFFFF; 
            box-sizing: border-box;

            display: flex; 
            align-items: center;
            justify-content: center; 
            flex-direction: column; 
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            /* BORDER-RADIUS CORRIGIDO: Arredondamento em baixo (topo da pilha) */
            border-radius: 0 0 4px 4px; 
            transition: all 0.3s ease-in-out;
            gap: 15px;
            padding: 5px;
        }
        #floating-info.active { 
            box-shadow: 0 0 15px rgba(15, 212, 247, 0.4); 
            border-radius: 40px 40px 40px 40px; 
        }
        #details-panel {
            width: 100%; /* üõë Ocupa 100% dos 250px definidos no wrapper */
            /*background-color: rgba(7, 7, 10, 0.9); */
            color: #E0E0E0;
        
            border-bottom: none; 
            padding: 0px; 
            box-sizing: border-box; 
            max-height: 0;
            overflow: hidden; 
            transition: max-height 0.4s ease-in-out, padding 0.4s ease-in-out;
            border-radius: 4px 4px 0 0;
        }
        #details-panel.open { 
            max-height: 500px; 
            padding: 10px; 
            border-radius: 4px 4px 0 0;
        }

        /* --- Card de Capital (TOOLTIP) --- */
        #capital-tooltip {
            position: absolute;
            background: rgba(255, 255, 255, 0.18);
            color: white;
            width: 200px;
            height: 200px;
            min-width: unset;
            padding: 10px;
            box-sizing: border-box;
            border-radius: 6px;
            pointer-events: none;
            transition: opacity 0.2s, transform 0.2s;
            opacity: 0;
            font-size: 14px;
            font-weight: 600;
            border-left: 4px solid #00AAFF;
            backdrop-filter: blur(8px);
            z-index: 1000;
            transform: translate(-50%, -100%);
            white-space: normal;
            overflow: hidden;
            position: relative;
        }
        #capital-tooltip.visible { opacity: 1; }

/* üõë CONTROLO DE ROTA√á√ÉO: Canto Inferior Direito (Configura√ß√£o Desktop) */
#rotation-control {
    position: absolute;
    bottom: 20px; /* Alinhado com o fundo */
    right: 20px; /* Alinha √† direita */
    left: auto; /* Garante alinhamento √† direita no Desktop */
    
    z-index: 101;
    background: rgba(0, 0, 0, 0.7);
    padding: 10px 15px;
    border-radius: 8px;
    color: white;
    font-size: 0.9em;
    display: none; /* Controlado por JS */
    flex-direction: column;
    gap: 10px;
    border: 1px solid rgba(255, 255, 255, 0.3);
    /* Largura fixa para Desktop */
    width: 250px; 
    min-width: unset; 
}

/* --- Mobile / Ecr√£s Pequenos (max-width: 768px) --- */
@media (max-width: 768px) {
    #rotation-control {
        /* Posi√ß√£o Mobile: Centrar na parte superior (ACIMA) do info-wrapper */
        /* bottom: 20px √© do info-wrapper, vamos posicionar este a 220px (200px do card + 20px de margem) */
        bottom: 20px; 
        right: auto;
        left: 50%;
        
        /* Largura total com margem de 20px de cada lado */
        width: calc(100% - 40px); 
        transform: translateX(-50%); /* Centraliza horizontalmente */
    }
}

        #rotation-control.visible {
            display: flex;
        }

        /* [Resto dos estilos de controlo e internos] */
        .control-group { display: flex; align-items: center; justify-content: space-between; gap: 10px; }
        .slider-group { justify-content: center; }
        #rotation-slider { flex-grow: 1; cursor: grab; margin: 0 5px; -webkit-appearance: none; appearance: none; background: transparent; }
        #rotation-slider::-webkit-slider-runnable-track { width: 100%; height: 12px; background: rgba(255, 255, 255, 0.2); border-radius: 6px; border: 1px solid rgba(255, 255, 255, 0.4); }
        #rotation-slider::-moz-range-track { width: 100%; height: 12px; background: rgba(255, 255, 255, 0.2); border-radius: 6px; border: 1px solid rgba(255, 255, 255, 0.4); }
        #rotation-slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; margin-top: -6px; height: 24px; width: 24px; border-radius: 50%; background: #00AAFF; border: 2px solid #FFF; cursor: grab; box-shadow: 0 0 5px rgba(0, 0, 0, 0.8); }
        #rotation-slider::-moz-range-thumb { height: 20px; width: 20px; border-radius: 50%; background: #00AAFF; border: 2px solid #FFF; cursor: grab; }
        .rotate-btn, .rotate-step-btn { padding: 5px 10px; border: 1px solid #444; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; font-weight: bold; color: #FFF; background-color: #222; }
        .rotate-step-btn { padding: 5px 12px; font-size: 1.1em; line-height: 1; }
        #toggle-rotate.active { background-color: #00AAFF; border-color: #00AAFF; }
        #toggle-rotate:not(.active) { border-color: #2596be; }
        .rotate-btn:hover, .rotate-step-btn:hover { background-color: #555; }
        #floating-info .data-value { font-size: 1.5em; font-weight: bold; color: #FFFFFF; line-height: 1; }
        #floating-info .unit { font-size: 0.8em; color: #CCCCCC; margin-top: 2px; }
        #floating-info .info-icon { width: 200px; height: 100px; object-fit: contain; margin-bottom: 5px; }
        #capital-tooltip b { font-size: 1.2em; display: block; margin-bottom: 5px; }
        #capital-tooltip ul { list-style-type: disc; padding-left: 15px; margin-top: 5px; margin-bottom: 0; font-size: 0.9em; font-weight: normal; line-height: 1.2; }
        #capital-tooltip .icon-bottom-right { position: absolute; bottom: -10; right: 0; width: 150px; height: 150px; opacity: 0.7; filter: drop-shadow(0px 0px 3px rgba(0, 0, 0, 0.5)); border-radius: 0 0 6px 0; object-fit: contain; }
        .pie-chart { width: 100px; height: 100px; margin: 10px auto; border-radius: 50%; background: conic-gradient( rgba(255, 255, 255, 1) 0% 30%, rgba(150, 150, 150, 1) 30% 70%, rgba(200, 200, 200, 1) 70% 90%, rgba(50, 50, 50, 1) 90% 100% ); }
        .legend-list { list-style: none; padding: 0; margin: 10px 0 0 0; font-size: 1.2em; }
        .legend-item { display: flex; justify-content: center; align-items: center; margin-bottom: 2px; gap: 10px; }
        .legend-color-box { width: 8px; height: 8px; margin-right: 5px; border-radius: 2px; display: inline-block; }
    </style>
</head>

<body>
    <div id="logo-top-left">
        <img src="https://static.wixstatic.com/media/a6967f_b1478a338afc4870879e1ba83f915dc5~mv2.png" alt="Logo MWS" />
    </div>

    <div id="container">
        <div id="capital-tooltip"></div>
    </div>
    
    <div id="zoom-controls">
        <button id="zoom-in" class="zoom-btn" title="Zoom In">+</button>
        <button id="zoom-out" class="zoom-btn" title="Zoom Out">-</button>
    </div>

    <div id="rotation-control">
        <div class="control-group">
            <label>Rota√ß√£o Autom√°tica:</label>
            <button id="toggle-rotate" class="rotate-btn active">ON</button>
        </div>

        <div class="control-group slider-group">
            <button id="rotate-left" class="rotate-step-btn" title="Girar para Esquerda">‚óÄ</button>
            <input type="range" id="rotation-slider" min="0" max="360" value="0" step="1" title="Ajuste Manual de Longitude">
            <button id="rotate-right" class="rotate-step-btn" title="Girar para Direita">‚ñ∂</button>
        </div>
    </div>

    <div id="info-wrapper">
        <div id="floating-info">
            <!--*<img src="https://static.wixstatic.com/media/a6967f_034c4bb41e814fc7b03969408024e9a1~mv2.png" alt="MWS Icon" class="info-icon"/>-->
            <span class="data-value">304 MWS</span>
        </div>

        <div id="details-panel">
            <div class="pie-chart"></div>

            <ul class="legend-list">
                <li class="legend-item">
                    <span><span class="legend-color-box" style="background-color: rgb(255, 255, 255);"></span>MWS300</span>
                    <span>30%</span>
                </li>
                <li class="legend-item">
                    <span><span class="legend-color-box" style="background-color: rgb(150, 150, 150);"></span>MWS500</span>
                    <span>40%</span>
                </li>
                <li class="legend-item">
                    <span><span class="legend-color-box" style="background-color: rgb(200, 200, 200);"></span>MWS700</span>
                    <span>20%</span>
                </li>
                <li class="legend-item">
                    <span><span class="legend-color-box" style="background-color: rgb(50, 50, 50);"></span>MWS715</span>
                    <span>10%</span>
                </li>
            </ul>
        </div>
    </div>

    <script type="text/javascript">
        let autoRotateEnabled = true;
        let deckgl;
        let rotationSlider;
        const MANUAL_STEP = 5;
        const ZOOM_STEP = 0.5;

        // --- Vari√°veis de Cor e Anima√ß√£o ---
        let colorAnimationTime = 0;
        const ANIMATION_CYCLE_MS = 6000;

        const ARC_PRIMARY_BLUE = [34, 108, 245, 200];
        const ARC_TARGET_WHITE = [255, 255, 255, 255];
        const POINT_PRIMARY_CYAN = [61, 208, 252, 255];
        const POINT_TARGET_WHITE_SOFT = [255, 255, 255, 255];

        // [Fun√ß√µes de Anima√ß√£o e Utilit√°rios]

        function lerpColor(c1, c2, t) {
            return [
                Math.round(c1[0] + (c2[0] - c1[0]) * t),
                Math.round(c1[1] + (c2[1] - c1[1]) * t),
                Math.round(c1[2] + (c2[2] - c1[2]) * t),
                Math.round(c1[3] + (c2[3] - c1[3]) * t)
            ];
        }

        function simpleHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash |= 0;
            }
            return Math.abs(hash);
        }

        function getAnimatedColorRandom(data, currentTime, initialColor, targetColor, cycleDuration) {
            const hashStr = data.name ? data.name : (data.source + data.target);
            const seed = simpleHash(hashStr);

            const offset = (seed % 10000) / 10000;

            const totalCycleTime = cycleDuration * 2;
            const normalizedTime = ((currentTime % totalCycleTime) / totalCycleTime) + offset;
            let t = normalizedTime % 1;

            if (t > 0.5) {
                t = 1 - (t - 0.5) * 2;
            } else {
                t = t * 2;
            }

            t = t * t * (3 - 2 * t); // Fun√ß√£o de suaviza√ß√£o
            return lerpColor(initialColor, targetColor, t);
        }
        
        function updateZoom(delta) {
            const newZoom = Math.max(1, Math.min(10, currentViewState.zoom + delta));
            
            currentViewState = {
                ...currentViewState,
                zoom: newZoom,
            };
            
            deckgl.setProps({ 
                viewState: {
                    ...currentViewState,
                    transitionDuration: 300, 
                    transitionInterpolator: new deck.FlyToInterpolator() 
                } 
            });
        }

        // --- FUN√á√ÉO DE ANIMA√á√ÉO DO GLOBO E DAS CORES (Loop Principal) ---
        let lastUpdateTime = 0;
        function animateFrame(timestamp) {
            if (!lastUpdateTime) lastUpdateTime = timestamp;
            const deltaTime = timestamp - lastUpdateTime;
            lastUpdateTime = timestamp;

            // 1. ANIMA√á√ÉO DA ROTA√á√ÉO
            if (autoRotateEnabled) {
                const ROTATION_SPEED = 0.10;
                const newLongitude = currentViewState.longitude + ROTATION_SPEED * (deltaTime / 16.6667);
                currentViewState = {
                    ...currentViewState,
                    longitude: newLongitude > 180 ? newLongitude - 360 : newLongitude
                };
                if (rotationSlider) {
                    let sliderValue = currentViewState.longitude + 180;
                    if (sliderValue > 360) sliderValue -= 360;
                    rotationSlider.value = sliderValue;
                }
            }

            // 2. ATUALIZA√á√ÉO DO TEMPO GLOBAL PARA A COR
            colorAnimationTime += deltaTime;

            // 3. ATUALIZAR O DECK.GL com as camadas animadas
            deckgl.setProps({
                viewState: currentViewState,
                layers: [
                    new deck.SolidPolygonLayer({ id: 'background', data: [[[-180, 90], [0, 90], [180, 90], [180, -90], [0, -90], [-180, -90]]], opacity: 1, getPolygon: d => d, stroked: false, filled: true, getFillColor: [25, 24, 34, 255], pickable: true, onClick: hideCapitalCard }),
                    new deck.GeoJsonLayer({ id: 'base-map', data: COUNTRIES, stroked: true, filled: true, lineWidthMinPixels: 0.5, getLineColor: [255, 255, 255], getFillColor: [7, 7, 10, 255], pickable: true, onClick: hideCapitalCard }),
                    new deck.GeoJsonLayer({ id: 'globe-outline', data: { type: 'Feature', geometry: { type: 'Sphere' } }, getLineColor: [255, 255, 255, 255], getLineWidth: 2, lineWidthUnits: 'pixels', lineWidthMinPixels: 1.5, stroked: true, filled: false }),

                    // Camada de Arcos Animados
                    new deck.ArcLayer({
                        id: 'arcs-portugal-selected',
                        data: ARC_DATA,
                        getSourcePosition: d => d.sourceCoords,
                        getTargetPosition: d => d.targetCoords,
                        getSourceColor: d => getAnimatedColorRandom(d, colorAnimationTime, ARC_PRIMARY_BLUE, ARC_TARGET_WHITE, ANIMATION_CYCLE_MS),
                        getTargetColor: d => getAnimatedColorRandom(d, colorAnimationTime, ARC_PRIMARY_BLUE, ARC_TARGET_WHITE, ANIMATION_CYCLE_MS),
                        getWidth: 0.5,
                        greatCircle: true,
                        autoHighlight: true,
                        highlightColor: [255, 255, 255, 255],
                        updateTriggers: {
                            getSourceColor: colorAnimationTime,
                            getTargetColor: colorAnimationTime
                        }
                    }),

                    // Ponto de Portugal (Est√°tico)
                    new deck.ScatterplotLayer({ 
                        id: 'portugal-point', 
                        data: [PORTUGAL_CAPITAL], 
                        getPosition: d => d.coords, 
                        getRadius: 80000, 
                        getFillColor: [0, 0, 255, 255], 
                        getLineColor: [0, 0, 0, 0], 
                        getLineWidth: 0.5, 
                        lineWidthMinPixels: 1, 
                        stroked: true, 
                        pickable: true, 
                        onClick: showCapitalCard 
                    }),

                    // Pontos de Capitais (Animados)
                    new deck.ScatterplotLayer({ 
                        id: 'target-capitals-points', 
                        data: selectedCapitalsData.filter(c => c.name !== PORTUGAL_CAPITAL.name), 
                        getPosition: d => d.coords, 
                        getRadius: 80000, 
                        getFillColor: d => getAnimatedColorRandom(d, colorAnimationTime, POINT_PRIMARY_CYAN, POINT_TARGET_WHITE_SOFT, ANIMATION_CYCLE_MS), 
                        getLineColor: [0, 0, 0], 
                        getLineWidth: 1, 
                        lineWidthMinPixels: 1, 
                        stroked: true, 
                        pickable: true, 
                        onClick: showCapitalCard,
                        updateTriggers: {
                            getFillColor: colorAnimationTime
                        }
                    })
                ]
            });

            requestAnimationFrame(animateFrame);
        }
        // ------------------------------------------------------------------
        
        // [Fun√ß√µes de Controlo de UI e Dados]

        function updateRotation(newLongitude) {
            currentViewState = {
                ...currentViewState,
                longitude: newLongitude
            };
            deckgl.setProps({ viewState: currentViewState, controller: true, transitionDuration: 0 });
        }

        function toggleGlobeMode(isPanelOpen) {
            const rotationControl = document.getElementById('rotation-control');
            const toggleRotate = document.getElementById('toggle-rotate');

            if (isPanelOpen) {
                autoRotateEnabled = true;
                deckgl.setProps({ controller: false, transitionDuration: 0 });
                toggleRotate.classList.add('active');
                toggleRotate.textContent = 'ON';
                rotationControl.classList.remove('visible');
            } else {
                autoRotateEnabled = false;
                deckgl.setProps({ controller: true, transitionDuration: 0 });
                toggleRotate.classList.remove('active');
                toggleRotate.textContent = 'OFF';
                rotationControl.classList.add('visible');
            }
        }
        
        function showCapitalCard(info) {
            const tooltip = document.getElementById('capital-tooltip');
            const MWS_OPTIONS = ["MWS300", "MWS500", "MWS700", "MWS715"];
            const IMAGE_URL = "https://static.wixstatic.com/media/a6967f_57a8d2b6c06a4b819541a54cab7694f4~mv2.png";

            const getRandomMWS = (used) => {
                let options = MWS_OPTIONS.filter(m => !used.includes(m));
                if (options.length === 0) options = MWS_OPTIONS;
                const selection = options[Math.floor(Math.random() * options.length)];
                return selection;
            };

            if (info.object) {
                autoRotateEnabled = false;

                const name = info.object.name || 'Ponto Desconhecido';

                const model1 = getRandomMWS([]);
                const model2 = getRandomMWS([model1]);

                const count1 = Math.floor(Math.random() * 5) + 1;
                const count2 = Math.floor(Math.random() * 5) + 1;

                const cardContent = `
                    Capital: <b style="font-size: 1.1em;">${name}</b>
                    <ul>
                        <li>${model1} - ${count1} eq.</li>
                        <li>${model2} - ${count2} eq.</li>
                    </ul>
                    <img src="${IMAGE_URL}" class="icon-bottom-right" alt="MWS Icon"/>
                `;

                const [x, y] = info.viewport.project(info.object.coords || info.object.position);

                tooltip.style.left = `${x}px`;
                tooltip.style.top = `${y}px`;
                tooltip.innerHTML = cardContent;
                tooltip.classList.add('visible');
            }
            return true;
        }

        function hideCapitalCard() {
            const tooltip = document.getElementById('capital-tooltip');
            tooltip.classList.remove('visible');
            return true;
        }


        // [Dados Deck.gl]
        const COUNTRIES = 'https://d2ad6b4ur7yvpq.cloudfront.net/naturalearth-3.3.0/ne_50m_admin_0_scale_rank.geojson';
        const PORTUGAL_CAPITAL = { name: "Lisboa (Portugal)", coords: [-9.1393, 38.7223] };

        const selectedCapitalsData = [
            { name: "Lisboa (Portugal)", country: "PORTUGAL", coords: PORTUGAL_CAPITAL.coords },
            { name: "Berlim", country: "ALEMANHA", coords: [13.405, 52.52] },
            { name: "Viena", country: "√ÅUSTRIA", coords: [16.3707, 48.2064] },
            { name: "Bruxelas", country: "B√âLGICA", coords: [4.3499, 50.8467] },
            { name: "Paris", country: "FRAN√áA", coords: [2.3522, 48.8566] },
            { name: "Madrid", country: "ESPANHA", coords: [-3.7038, 40.4168] },
            { name: "Estocolmo", country: "SU√âCIA", coords: [18.0686, 59.3293] },
            { name: "Copenhaga", country: "DINAMARCA", coords: [12.5683, 55.6761] },
            { name: "Hels√≠nquia", country: "FINL√ÇNDIA", coords: [24.9458, 60.1708] },
            { name: "Minsk", country: "BIELORR√öSSIA", coords: [27.5667, 53.9] },
            { name: "S√≥fia", country: "BULG√ÅRIA", coords: [23.3242, 42.6975] },
            { name: "Budapeste", country: "HUNGRIA", coords: [19.0402, 47.4979] },
            { name: "Vilnius", country: "LITU√ÇNIA", coords: [25.2798, 54.6872] },
            { name: "Vars√≥via", country: "POL√ìNIA", coords: [21.0175, 52.2297] },
            { name: "Bras√≠lia", country: "BRASIL", coords: [-47.9297, -15.7797] },
            { name: "Ottawa", country: "CANAD√Å", coords: [-75.698, 45.4166] },
            { name: "Santiago", country: "CHILE", coords: [-70.6693, -33.4489] },
            { name: "San Salvador", country: "EL SALVADOR", coords: [-89.1872, 13.6929] },
            { name: "Cidade da Guatemala", country: "GUATEMALA", coords: [-90.5069, 14.6349] },
            { name: "Tegucigalpa", country: "HONDURAS", coords: [-87.2068, 14.0822] },
            { name: "Cidade do M√©xico", country: "M√âXICO", coords: [-99.1333, 19.4333] },
            { name: "Washington D.C.", country: "EUA", coords: [-77.0369, 38.9072] },
            { name: "Camberra", country: "AUSTR√ÅLIA", coords: [149.1281, -35.2835] },
            { name: "Doha", country: "CATAR", coords: [51.531, 25.2854] },
            { name: "Riade", country: "AR√ÅBIA SAUDITA", coords: [46.7385, 24.7136] },
            { name: "Jerusal√©m", country: "ISRAEL", coords: [35.2163, 31.7683] },
            { name: "Roma", country: "IT√ÅLIA", coords: [12.4964, 41.9028] },
            { name: "Atenas", country: "GR√âCIA", coords: [23.7275, 37.9838] },
            { name: "Moscovo", country: "R√öSSIA", coords: [37.6173, 55.7558] },
            { name: "Singapura", country: "SINGAPURA", coords: [103.8198, 1.3521] },
            { name: "Taipei", country: "TAIWAN", coords: [121.5654, 25.033] },
            { name: "Ulaanbaatar", country: "MONG√ìLIA", coords: [106.9055, 47.919] },
            { name: "Tashkent", country: "UZBEQUIST√ÉO", coords: [69.2797, 41.2995] }
        ];

        function generateArcData_FromPortugal(capitals) {
            const arcs = [];
            const otherCapitals = capitals.filter(c => c.name !== PORTUGAL_CAPITAL.name);
            otherCapitals.forEach(targetCapital => {
                arcs.push({ source: PORTUGAL_CAPITAL.name, target: targetCapital.name, sourceCoords: PORTUGAL_CAPITAL.coords, targetCoords: targetCapital.coords });
            });
            return arcs;
        }

        const ARC_DATA = generateArcData_FromPortugal(selectedCapitalsData);

        // --- L√ìGICA DE DETE√á√ÉO DE TELEM√ìVEL E AJUSTE DE VIS√ÉO (CORRIGIDA) ---
        function isMobileView() {
            return window.innerWidth <= 768; 
        }

        let initialZoom = 2.5; 
        let initialLatitude = PORTUGAL_CAPITAL.coords[1]; 
        let initialPitch = 10; 

        if (isMobileView()) {
            // Mant√©m o zoom em 1.0 para mobile
            initialZoom = 1.0; 
            
            // CORRIGIDO: Latitude ajustada para 45 e Pitch para 50. 
            // O Pitch mais alto compensa o zoom baixo e "empurra" o globo para cima.
            initialLatitude = 45; 
            initialPitch = 50; 
        }
        // --------------------------------------------------------

        let currentViewState = {
            latitude: initialLatitude, 
            longitude: PORTUGAL_CAPITAL.coords[0],
            zoom: initialZoom, 
            pitch: initialPitch 
        };

        function handleViewStateChange(viewState, interactionContext) {
            if (interactionContext.isDragging || interactionContext.isRotating) {
                autoRotateEnabled = false;
                document.getElementById('toggle-rotate').classList.remove('active');
                document.getElementById('toggle-rotate').textContent = 'OFF';

                if (rotationSlider) {
                    let sliderValue = viewState.longitude + 180;
                    if (sliderValue > 360) sliderValue -= 360;
                    rotationSlider.value = sliderValue;
                }
            }
            else if (!interactionContext.isDragging && !interactionContext.isRotating && !autoRotateEnabled) {
                const detailsPanel = document.getElementById('details-panel');
                if (detailsPanel && detailsPanel.classList.contains('open')) {
                    autoRotateEnabled = true;
                    document.getElementById('toggle-rotate').classList.add('active');
                    document.getElementById('toggle-rotate').textContent = 'ON';
                } else {
                    autoRotateEnabled = false;
                }
            }

            currentViewState = {
                ...viewState,
                isDragging: interactionContext.isDragging,
                zoom: viewState.zoom
            };

            return viewState;
        }

        deckgl = new deck.DeckGL({
            container: 'container',
            getTooltip: ({ object }) => object && `Capital: ${object.name}`,

            views: new deck._GlobeView(),
            initialViewState: currentViewState,
            controller: true,
            onViewStateChange: ({ viewState, interactionContext }) => {
                return handleViewStateChange(viewState, interactionContext);
            },
            layers: [
                new deck.SolidPolygonLayer({ id: 'background', data: [[[-180, 90], [0, 90], [180, 90], [180, -90], [0, -90], [-180, -90]]], opacity: 1, getPolygon: d => d, stroked: false, filled: true, getFillColor: [25, 24, 34, 255], pickable: true, onClick: hideCapitalCard }),
                new deck.GeoJsonLayer({ id: 'base-map', data: COUNTRIES, stroked: true, filled: true, lineWidthMinPixels: 0.5, getLineColor: [255, 255, 255], getFillColor: [7, 7, 10, 255], pickable: true, onClick: hideCapitalCard }),
                new deck.GeoJsonLayer({ id: 'globe-outline', data: { type: 'Feature', geometry: { type: 'Sphere' } }, getLineColor: [255, 255, 255, 255], getLineWidth: 2, lineWidthUnits: 'pixels', lineWidthMinPixels: 1.5, stroked: true, filled: false }),
                new deck.ArcLayer({
                    id: 'arcs-portugal-selected',
                    data: ARC_DATA,
                    getSourcePosition: d => d.sourceCoords,
                    getTargetPosition: d => d.targetCoords,
                    getSourceColor: ARC_PRIMARY_BLUE,
                    getTargetColor: ARC_PRIMARY_BLUE,
                    getWidth: 0.5,
                    greatCircle: true,
                    autoHighlight: true,
                    highlightColor: [255, 255, 255, 255]
                }),
                new deck.ScatterplotLayer({ id: 'portugal-point', data: [PORTUGAL_CAPITAL], getPosition: d => d.coords, getRadius: 80000, getFillColor: [0, 0, 255, 255], getLineColor: [0, 0, 0, 0], getLineWidth: 0.5, lineWidthMinPixels: 1, stroked: true, pickable: true, onClick: showCapitalCard }),
                new deck.ScatterplotLayer({ id: 'target-capitals-points', data: selectedCapitalsData.filter(c => c.name !== PORTUGAL_CAPITAL.name), getPosition: d => d.coords, getRadius: 80000, getFillColor: POINT_PRIMARY_CYAN, getLineColor: [0, 0, 0], getLineWidth: 1, lineWidthMinPixels: 1, stroked: true, pickable: true, onClick: showCapitalCard })
            ]
        });

        document.addEventListener('DOMContentLoaded', () => {
            const floatingInfo = document.getElementById('floating-info');
            const detailsPanel = document.getElementById('details-panel');
            rotationSlider = document.getElementById('rotation-slider');
            const toggleRotate = document.getElementById('toggle-rotate');
            const rotateLeftBtn = document.getElementById('rotate-left');
            const rotateRightBtn = document.getElementById('rotate-right');
            
            // Bot√µes de Zoom
            const zoomInBtn = document.getElementById('zoom-in');
            const zoomOutBtn = document.getElementById('zoom-out');

            floatingInfo.addEventListener('click', () => {
                const wasOpen = detailsPanel.classList.contains('open');
                hideCapitalCard();
                detailsPanel.classList.toggle('open');
                floatingInfo.classList.toggle('active');
                toggleGlobeMode(!wasOpen);
            });

            toggleRotate.addEventListener('click', () => {
                const isActive = toggleRotate.classList.toggle('active');
                toggleRotate.textContent = isActive ? 'ON' : 'OFF';

                if (isActive) {
                    autoRotateEnabled = true;
                    deckgl.setProps({ controller: false, transitionDuration: 0 });
                } else {
                    autoRotateEnabled = false;
                    deckgl.setProps({ controller: true, transitionDuration: 0 });
                }
            });

            rotationSlider.addEventListener('input', (event) => {
                autoRotateEnabled = false;
                toggleRotate.classList.remove('active');
                toggleRotate.textContent = 'OFF';
                const newLongitude = parseFloat(event.target.value) - 180;
                updateRotation(newLongitude);
            });

            function handleStepRotation(direction) {
                autoRotateEnabled = false;
                toggleRotate.classList.remove('active');
                toggleRotate.textContent = 'OFF';
                const step = direction * MANUAL_STEP;
                let newLongitude = currentViewState.longitude + step;

                if (newLongitude > 180) newLongitude -= 360;
                if (newLongitude < -180) newLongitude += 360;

                let sliderValue = newLongitude + 180;
                if (sliderValue > 360) sliderValue -= 360;
                rotationSlider.value = sliderValue;
                updateRotation(newLongitude);
            }

            rotateLeftBtn.addEventListener('click', () => handleStepRotation(-1));
            rotateRightBtn.addEventListener('click', () => handleStepRotation(1));
            
            zoomInBtn.addEventListener('click', () => updateZoom(ZOOM_STEP));
            zoomOutBtn.addEventListener('click', () => updateZoom(-ZOOM_STEP));
            
            animateFrame(0);
            toggleGlobeMode(false);
        });
    </script>
</body>
</html>
